<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VoiceBridge - Real-Time Voice Translator</title>
    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6124600354172819"
      crossorigin="anonymous"
    ></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css"
    />
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f8f9fa;
      }
      .container {
        max-width: 600px;
      }
      .mic-button {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        background-color: #4285f4;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 4px 10px rgba(66, 133, 244, 0.3);
      }
      .mic-button:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 20px rgba(66, 133, 244, 0.3);
      }
      .mic-button:active {
        background-color: #ff5252;
        transform: scale(0.95);
      }
      .mic-button.recording {
        background-color: #ff5252;
        transform: scale(1.05);
        box-shadow: 0 4px 20px rgba(255, 82, 82, 0.4);
      }
      .mic-button.disabled {
        background-color: #c4c4c4;
        cursor: not-allowed;
      }
      .mic-icon {
        width: 50px;
        height: 60px;
      }
      .language-selector {
        border: 1px solid #e0e0e0;
        border-radius: 25px;
        padding: 12px 20px;
        background-color: white;
        width: 140px;
        text-align: center;
        font-weight: 600;
        color: #172b4d;
        position: relative;
        cursor: pointer;
      }
      @media (max-width: 640px) {
        .language-selector {
          width: 120px;
          padding: 10px 15px;
          font-size: 14px;
        }
        .mic-button {
          width: 100px;
          height: 100px;
        }
        .mic-icon {
          width: 40px;
          height: 50px;
        }
      }
      .language-selector::after {
        content: "\f078";
        font-family: "Font Awesome 5 Free";
        font-weight: 900;
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 12px;
      }
      .translate-arrow {
        color: #c4c4c4;
        font-size: 24px;
      }
      .transcript-box {
        border: 1px solid #e0e0e0;
        border-radius: 15px;
        padding: 20px;
        background-color: white;
        min-height: 100px;
        width: 100%;
        margin: 15px 0;
      }
      .play-button {
        border-radius: 30px;
        background-color: #4285f4;
        color: white;
        padding: 12px 25px;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
        gap: 10px;
        transition: all 0.2s ease;
      }
      .play-button:hover {
        background-color: #3367d6;
      }
      .play-button.disabled {
        background-color: #c4c4c4;
        cursor: not-allowed;
      }
      .history-item {
        border-radius: 10px;
        background-color: white;
        padding: 15px;
        margin-bottom: 10px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      }
      .pulse-animation {
        animation: pulse 1.5s infinite;
      }
      @keyframes pulse {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.05);
          opacity: 0.8;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      .recording-dot {
        width: 12px;
        height: 12px;
        background-color: #f44336;
        border-radius: 50%;
        display: inline-block;
        margin-right: 5px;
      }
      .loading-spinner {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #3498db;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        animation: spin 1s linear infinite;
        display: inline-block;
        margin-right: 10px;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      .error-message {
        color: #f44336;
        margin-top: 5px;
      }
      .footer {
        text-align: center;
        padding: 15px 0;
        font-size: 14px;
        color: #666;
        margin-top: 30px;
        border-top: 1px solid #eee;
      }
      .push-to-talk-hint {
        text-align: center;
        margin-top: 5px;
        font-size: 14px;
        color: #666;
      }
      .view-history-button {
        border-radius: 30px;
        background-color: #34a853;
        color: white;
        padding: 10px 20px;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
        cursor: pointer;
      }
      .view-history-button:hover {
        background-color: #2e9549;
      }
      .clear-history-button {
        border-radius: 30px;
        background-color: #ea4335;
        color: white;
        padding: 8px 16px;
        font-weight: 600;
        font-size: 14px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
        margin-left: 10px;
      }
      .clear-history-button:hover {
        background-color: #d33426;
      }
      .history-modal {
        max-height: 70vh;
        overflow-y: auto;
      }
      .history-date-group {
        border-bottom: 1px solid #eee;
        margin-bottom: 15px;
        padding-bottom: 10px;
      }
      .history-date-label {
        font-weight: 600;
        color: #4285f4;
        margin-bottom: 10px;
      }
    </style>
  </head>
  <body class="py-6">
    <div class="container mx-auto px-4">
      <!-- Header -->
      <h1
        class="text-3xl md:text-4xl font-bold text-center text-gray-800 mb-6 md:mb-10"
      >
        VoiceBridge
      </h1>

      <!-- Language Selector -->
      <div class="flex justify-center items-center mb-6 md:mb-8 gap-2 md:gap-4">
        <div class="language-selector" id="sourceLanguage">Telugu</div>
        <div class="translate-arrow">
          <i class="fas fa-arrow-right"></i>
        </div>
        <div class="language-selector" id="targetLanguage">Hindi</div>
      </div>

      <!-- Microphone Button -->
      <div class="flex justify-center mb-4">
        <div class="mic-button" id="micButton">
          <svg
            class="mic-icon"
            fill="white"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"
            />
            <path
              d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"
            />
          </svg>
        </div>
      </div>

      <!-- Push-to-talk hint -->
      <p class="push-to-talk-hint mb-4">Press and hold to speak</p>

      <!-- Live Transcription Box -->
      <div class="transcript-box mb-4" id="transcriptionBox">
        <div id="recordingIndicator" class="hidden items-center mb-2">
          <span class="recording-dot pulse-animation"></span>
          <span class="text-sm text-red-600">Recording...</span>
        </div>
        <div id="translatingIndicator" class="hidden items-center mb-2">
          <span class="loading-spinner"></span>
          <span class="text-sm text-blue-600">Translating...</span>
        </div>
        <p id="transcriptionText" class="text-gray-700">
          Press and hold the microphone button to speak
        </p>
        <p
          id="translationText"
          class="text-gray-900 font-medium mt-4 hidden"
        ></p>
        <p id="errorText" class="error-message hidden"></p>
      </div>

      <!-- Play Translation Button -->
      <div class="flex justify-center mb-6">
        <button class="play-button disabled" id="playButton" disabled>
          <i class="fas fa-volume-up"></i>
          Play Translation
        </button>
      </div>

      <!-- Translation History -->
      <div class="mt-8">
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-xl font-semibold text-gray-700">
            Recent Translations
          </h2>
          <button class="view-history-button" id="viewHistoryButton">
            <i class="fas fa-history"></i>
            View All History
          </button>
        </div>
        <div id="historyContainer">
          <!-- History items will be added here -->
        </div>
      </div>

      <!-- Language Selection Modal -->
      <div
        id="languageModal"
        class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50"
      >
        <div
          class="bg-white rounded-lg p-4 md:p-6 w-72 md:w-80 max-h-96 overflow-y-auto"
        >
          <h3 class="text-lg font-semibold mb-4">Select Language</h3>
          <div class="space-y-2 mb-4" id="languageOptionsList">
            <div
              class="p-2 hover:bg-gray-100 rounded cursor-pointer language-option"
            >
              Telugu
            </div>
            <div
              class="p-2 hover:bg-gray-100 rounded cursor-pointer language-option"
            >
              Hindi
            </div>
            <div
              class="p-2 hover:bg-gray-100 rounded cursor-pointer language-option"
            >
              English
            </div>
            <div
              class="p-2 hover:bg-gray-100 rounded cursor-pointer language-option"
            >
              Tamil
            </div>
            <div
              class="p-2 hover:bg-gray-100 rounded cursor-pointer language-option"
            >
              Kannada
            </div>
            <div
              class="p-2 hover:bg-gray-100 rounded cursor-pointer language-option"
            >
              French
            </div>
            <div
              class="p-2 hover:bg-gray-100 rounded cursor-pointer language-option"
            >
              Spanish
            </div>
            <div
              class="p-2 hover:bg-gray-100 rounded cursor-pointer language-option"
            >
              German
            </div>
            <div
              class="p-2 hover:bg-gray-100 rounded cursor-pointer language-option"
            >
              Japanese
            </div>
            <div
              class="p-2 hover:bg-gray-100 rounded cursor-pointer language-option"
            >
              Chinese
            </div>
          </div>
          <div class="flex justify-end">
            <button id="closeModal" class="px-4 py-2 bg-gray-200 rounded">
              Cancel
            </button>
          </div>
        </div>
      </div>

      <!-- History Modal -->
      <div
        id="historyModal"
        class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50"
      >
        <div
          class="bg-white rounded-lg p-4 md:p-6 w-11/12 md:w-3/4 lg:w-2/3 history-modal"
        >
          <div class="flex justify-between items-center mb-4">
            <h3 class="text-lg font-semibold">Translation History</h3>
            <div>
              <button id="clearHistoryButton" class="clear-history-button">
                <i class="fas fa-trash-alt"></i> Clear All
              </button>
              <button
                id="closeHistoryModal"
                class="ml-2 px-4 py-2 bg-gray-200 rounded"
              >
                Close
              </button>
            </div>
          </div>
          <div id="fullHistoryContainer">
            <!-- All history items will be loaded here -->
          </div>
        </div>
      </div>

      <!-- Footer with copyright -->
      <div class="footer">&copy; 2023 VoiceBridge | Built by Suraj Mandal</div>
    </div>

    <script>
      // DOM Elements
      const micButton = document.getElementById("micButton");
      const playButton = document.getElementById("playButton");
      const transcriptionText = document.getElementById("transcriptionText");
      const translationText = document.getElementById("translationText");
      const errorText = document.getElementById("errorText");
      const recordingIndicator = document.getElementById("recordingIndicator");
      const translatingIndicator = document.getElementById(
        "translatingIndicator"
      );
      const historyContainer = document.getElementById("historyContainer");
      const sourceLanguage = document.getElementById("sourceLanguage");
      const targetLanguage = document.getElementById("targetLanguage");
      const languageModal = document.getElementById("languageModal");
      const closeModal = document.getElementById("closeModal");
      const languageOptions = document.querySelectorAll(".language-option");
      const viewHistoryButton = document.getElementById("viewHistoryButton");
      const historyModal = document.getElementById("historyModal");
      const closeHistoryModal = document.getElementById("closeHistoryModal");
      const clearHistoryButton = document.getElementById("clearHistoryButton");
      const fullHistoryContainer = document.getElementById(
        "fullHistoryContainer"
      );

      // State variables
      let isRecording = false;
      let isTranslating = false;
      let currentLanguageSelector = null;
      let recognition = null;
      let currentTranscription = "";
      let currentTranslation = "";
      let isPushToTalk = true; // Enable push-to-talk mode by default
      let translationHistory = []; // Array to store all translations

      // Language codes mapping for different APIs
      const languageCodes = {
        // Speech Recognition codes (BCP 47)
        speech: {
          Telugu: "te-IN",
          Hindi: "hi-IN",
          English: "en-US",
          Tamil: "ta-IN",
          Kannada: "kn-IN",
          French: "fr-FR",
          Spanish: "es-ES",
          German: "de-DE",
          Japanese: "ja-JP",
          Chinese: "zh-CN",
        },
        // Translation API codes
        translation: {
          Telugu: "te",
          Hindi: "hi",
          English: "en",
          Tamil: "ta",
          Kannada: "kn",
          French: "fr",
          Spanish: "es",
          German: "de",
          Japanese: "ja",
          Chinese: "zh-CN",
        },
      };

      // Initialize Speech Recognition
      function initSpeechRecognition() {
        if (
          "webkitSpeechRecognition" in window ||
          "SpeechRecognition" in window
        ) {
          recognition = new (window.SpeechRecognition ||
            window.webkitSpeechRecognition)();
          recognition.continuous = true;
          recognition.interimResults = true;

          // Set language based on source language selection
          recognition.lang =
            languageCodes.speech[sourceLanguage.textContent.trim()] || "te-IN";

          recognition.onstart = () => {
            isRecording = true;
            micButton.classList.add("recording");
            micButton.classList.add("pulse-animation");
            recordingIndicator.classList.remove("hidden");
            recordingIndicator.classList.add("flex");
            transcriptionText.textContent = "Listening...";
            translationText.classList.add("hidden");
            errorText.classList.add("hidden");
          };

          recognition.onresult = (event) => {
            let interimTranscript = "";
            let finalTranscript = "";

            for (let i = event.resultIndex; i < event.results.length; i++) {
              const transcript = event.results[i][0].transcript;
              if (event.results[i].isFinal) {
                finalTranscript += transcript;
              } else {
                interimTranscript += transcript;
              }
            }

            if (finalTranscript) {
              currentTranscription = finalTranscript;
              transcriptionText.textContent = finalTranscript;

              // After getting final transcript, translate it
              translateText(finalTranscript);
            } else if (interimTranscript) {
              transcriptionText.textContent = interimTranscript;
            }
          };

          recognition.onerror = (event) => {
            console.error("Speech recognition error", event.error);

            // Show error message based on the type of error
            if (event.error === "no-speech") {
              showError("No speech detected. Please try again.");
            } else if (event.error === "audio-capture") {
              showError(
                "Microphone not found. Please check your microphone settings."
              );
            } else if (event.error === "not-allowed") {
              showError(
                "Microphone access denied. Please allow microphone access."
              );
            } else {
              showError("Speech recognition error. Please try again.");
            }

            stopRecording();
          };

          recognition.onend = () => {
            // Only stop if not in push-to-talk mode or if explicitly stopped
            if (!isPushToTalk || !isRecording) {
              stopRecording();
            }
          };
        } else {
          showError(
            "Speech recognition is not supported in your browser. Please try Chrome or Edge."
          );
          micButton.classList.add("disabled");
          micButton.disabled = true;
        }
      }

      // Show error message
      function showError(message) {
        errorText.textContent = message;
        errorText.classList.remove("hidden");
      }

      // Start recording
      function startRecording() {
        if (recognition) {
          try {
            recognition.start();
          } catch (error) {
            console.error("Recognition start error:", error);
            // If already started, stop it and start again
            if (error.name === "InvalidStateError") {
              recognition.stop();
              setTimeout(() => {
                recognition.start();
              }, 100);
            }
          }
        } else {
          initSpeechRecognition();
          setTimeout(() => {
            if (recognition) recognition.start();
          }, 100);
        }
      }

      // Stop recording
      function stopRecording() {
        if (recognition) {
          try {
            recognition.stop();
          } catch (error) {
            console.error("Recognition stop error:", error);
          }
        }

        isRecording = false;
        micButton.classList.remove("recording");
        micButton.classList.remove("pulse-animation");
        recordingIndicator.classList.add("hidden");
        recordingIndicator.classList.remove("flex");
      }

      // Push-to-talk handlers
      function setupPushToTalk() {
        // For traditional mouse events
        micButton.addEventListener("mousedown", onPushStart);
        document.addEventListener("mouseup", onPushEnd);

        // For touch events (mobile devices)
        micButton.addEventListener("touchstart", onPushStart);
        document.addEventListener("touchend", onPushEnd);

        // Add event to handle case when mouse/touch leaves the button while still pressed
        micButton.addEventListener("mouseleave", onPushLeave);
        document.addEventListener("touchcancel", onPushEnd);

        // Prevent context menu on long press (mobile)
        micButton.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          return false;
        });
      }

      function onPushStart(e) {
        e.preventDefault();
        if (micButton.classList.contains("disabled") || !isPushToTalk) return;

        startRecording();
      }

      function onPushEnd(e) {
        if (!isPushToTalk || !isRecording) return;

        // Check if the event is related to the mic button
        if (e.type === "touchend") {
          // For touch events, we need to stop recording regardless
          stopRecording();
        } else if (e.type === "mouseup") {
          // For mouse events, we stop recording
          stopRecording();
        }
      }

      function onPushLeave(e) {
        // If mouse leaves button while still pressed, stop recording
        if (isPushToTalk && isRecording && e.type === "mouseleave") {
          stopRecording();
        }
      }

      // Translate text using a translation API
      async function translateText(text) {
        if (!text || text.trim() === "") {
          return;
        }

        isTranslating = true;
        translatingIndicator.classList.remove("hidden");
        translatingIndicator.classList.add("flex");

        const sourceLang = sourceLanguage.textContent.trim();
        const targetLang = targetLanguage.textContent.trim();

        try {
          // Get language codes for the API
          const sourceCode = languageCodes.translation[sourceLang] || "te";
          const targetCode = languageCodes.translation[targetLang] || "hi";

          // Show that we're translating
          errorText.classList.add("hidden");

          // ===============================================================
          // OPTION 1: Google Translate API via RapidAPI (Free tier available)
          // Sign up at RapidAPI.com and get a free API key with limited usage
          // ===============================================================

          try {
            // For production, replace "YOUR_RAPIDAPI_KEY" with your actual key
            const rapidApiKey = "YOUR_RAPIDAPI_KEY";

            // Don't make the API call if no key is provided
            if (rapidApiKey !== "YOUR_RAPIDAPI_KEY") {
              const response = await fetch(
                `https://google-translate1.p.rapidapi.com/language/translate/v2`,
                {
                  method: "POST",
                  headers: {
                    "content-type": "application/x-www-form-urlencoded",
                    "Accept-Encoding": "application/gzip",
                    "X-RapidAPI-Key": rapidApiKey,
                    "X-RapidAPI-Host": "google-translate1.p.rapidapi.com",
                  },
                  body: new URLSearchParams({
                    q: text,
                    source: sourceCode,
                    target: targetCode,
                  }),
                }
              );

              if (response.ok) {
                const data = await response.json();
                if (
                  data &&
                  data.data &&
                  data.data.translations &&
                  data.data.translations.length > 0
                ) {
                  const translatedText =
                    data.data.translations[0].translatedText;

                  // Update UI with translation
                  currentTranslation = translatedText;
                  translationText.textContent = translatedText;
                  translationText.classList.remove("hidden");

                  // Enable play button
                  playButton.classList.remove("disabled");
                  playButton.disabled = false;

                  // Add to history
                  addToHistory(text, translatedText, sourceLang, targetLang);

                  return; // Exit early if API call was successful
                }
              }
            }

            // If we get here, the API call failed or wasn't attempted, fall through to the next method
          } catch (apiError) {
            console.error("RapidAPI translation error:", apiError);
            // Fall through to next option if this fails
          }

          // ===============================================================
          // OPTION 2: LibreTranslate API (Open Source & Free)
          // ===============================================================

          try {
            const libreTranslateUrl = "https://libretranslate.com/translate";
            // Note: Some instances may require an API key or have rate limits

            const response = await fetch(libreTranslateUrl, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                q: text,
                source: sourceCode,
                target: targetCode,
              }),
            });

            if (response.ok) {
              const data = await response.json();
              if (data && data.translatedText) {
                const translatedText = data.translatedText;

                // Update UI with translation
                currentTranslation = translatedText;
                translationText.textContent = translatedText;
                translationText.classList.remove("hidden");

                // Enable play button
                playButton.classList.remove("disabled");
                playButton.disabled = false;

                // Add to history
                addToHistory(text, translatedText, sourceLang, targetLang);

                return; // Exit early if API call was successful
              }
            }

            // If we get here, the API call failed, fall through to the next method
          } catch (libreError) {
            console.error("LibreTranslate error:", libreError);
            // Fall through to next option if this fails
          }

          // ===============================================================
          // OPTION 3: MyMemory Translation API (Free for limited usage)
          // ===============================================================

          try {
            // MyMemory has a generous free tier (100 requests/day)
            const myMemoryUrl = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(
              text
            )}&langpair=${sourceCode}|${targetCode}`;

            const response = await fetch(myMemoryUrl);

            if (response.ok) {
              const data = await response.json();
              if (
                data &&
                data.responseData &&
                data.responseData.translatedText
              ) {
                let translatedText = data.responseData.translatedText;

                // Update UI with translation
                currentTranslation = translatedText;
                translationText.textContent = translatedText;
                translationText.classList.remove("hidden");

                // Enable play button
                playButton.classList.remove("disabled");
                playButton.disabled = false;

                // Add to history
                addToHistory(text, translatedText, sourceLang, targetLang);

                return; // Exit early if API call was successful
              }
            }

            // If we get here, the API call failed, fall through to fallback
          } catch (myMemoryError) {
            console.error("MyMemory translation error:", myMemoryError);
            // Fall through to fallback option
          }

          // ===============================================================
          // FALLBACK: If all API calls fail, use our fallback system
          // ===============================================================

          console.log("All API calls failed, using fallback translation");

          // Simulate API call delay
          await new Promise((resolve) => setTimeout(resolve, 500));

          // Use our fallback translation system
          let translatedText = "";

          // Basic phrase detection for demo purposes (simplistic approach)
          const lowerText = text.toLowerCase();

          if (targetLang === "Hindi") {
            if (
              lowerText.includes("hello") ||
              lowerText.includes("hi") ||
              lowerText.includes("hey")
            ) {
              translatedText = "नमस्ते";
            } else if (lowerText.includes("how are you")) {
              translatedText = "आप कैसे हैं?";
            } else if (
              lowerText.includes("eat") ||
              lowerText.includes("ate") ||
              lowerText.includes("food")
            ) {
              translatedText = "क्या आपने खाना खाया?";
            } else if (lowerText.includes("name")) {
              translatedText = "आपका नाम क्या है?";
            } else if (lowerText.includes("thank")) {
              translatedText = "धन्यवाद";
            } else if (lowerText.includes("welcome")) {
              translatedText = "आपका स्वागत है";
            } else if (lowerText.includes("good morning")) {
              translatedText = "सुप्रभात";
            } else if (lowerText.includes("good night")) {
              translatedText = "शुभ रात्रि";
            } else if (lowerText.includes("sorry")) {
              translatedText = "माफ़ कीजिये";
            } else if (lowerText.includes("yes")) {
              translatedText = "हां";
            } else if (lowerText.includes("no")) {
              translatedText = "नहीं";
            } else if (lowerText.includes("water")) {
              translatedText = "पानी";
            } else if (lowerText.includes("work")) {
              translatedText = "काम";
            } else if (lowerText.includes("today")) {
              translatedText = "आज";
            } else if (lowerText.includes("tomorrow")) {
              translatedText = "कल";
            } else if (lowerText.includes("yesterday")) {
              translatedText = "कल";
            } else {
              // Use the text hash to create a slightly randomized translation for unknown phrases
              const inputHash = hashString(text);
              const variants = [
                "मुझे समझ नहीं आया, कृपया फिर से बोलें",
                `${text} का हिंदी अनुवाद`,
                `यह हिंदी में अनुवादित वाक्य है`,
                `क्या आप ${inputHash % 10} बजे मिल सकते हैं?`,
                `मैं ${sourceLang} से ${targetLang} में अनुवाद कर रहा हूं`,
              ];
              translatedText = variants[inputHash % variants.length];
            }
          } else if (targetLang === "Telugu") {
            if (
              lowerText.includes("hello") ||
              lowerText.includes("hi") ||
              lowerText.includes("hey")
            ) {
              translatedText = "నమస్కారం";
            } else if (lowerText.includes("how are you")) {
              translatedText = "మీరు ఎలా ఉన్నారు?";
            } else if (
              lowerText.includes("eat") ||
              lowerText.includes("ate") ||
              lowerText.includes("food")
            ) {
              translatedText = "మీరు తిన్నారా?";
            } else if (lowerText.includes("name")) {
              translatedText = "మీ పేరు ఏమిటి?";
            } else {
              // Fallback for Telugu
              translatedText = `తెలుగులో: ${text}`;
            }
          } else if (targetLang === "English") {
            if (
              lowerText.includes("నమస్కారం") ||
              lowerText.includes("नमस्ते")
            ) {
              translatedText = "Hello";
            } else if (
              lowerText.includes("ఎలా ఉన్నారు") ||
              lowerText.includes("कैसे हैं")
            ) {
              translatedText = "How are you?";
            } else {
              // Simple fallback for English - just echo back
              translatedText = text;
            }
          } else {
            // For other languages, create a placeholder that changes based on the input
            translatedText = `[${targetLang} translation of: ${text}]`;
          }

          // Update UI with translation
          currentTranslation = translatedText;
          translationText.textContent = translatedText;
          translationText.classList.remove("hidden");

          // Enable play button
          playButton.classList.remove("disabled");
          playButton.disabled = false;

          // Add to history
          addToHistory(text, translatedText, sourceLang, targetLang);
        } catch (error) {
          console.error("Translation error:", error);
          showError(
            "Translation error: " + (error.message || "Failed to fetch")
          );
        } finally {
          isTranslating = false;
          translatingIndicator.classList.add("hidden");
          translatingIndicator.classList.remove("flex");
        }
      }

      // Helper function to create a simple hash of a string
      function hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          hash = (hash << 5) - hash + str.charCodeAt(i);
          hash |= 0;
        }
        return Math.abs(hash);
      }

      // Play translated text using speech synthesis
      function playTranslation() {
        if (!currentTranslation || playButton.disabled) {
          return;
        }

        if ("speechSynthesis" in window) {
          // Cancel any ongoing speech
          window.speechSynthesis.cancel();

          const utterance = new SpeechSynthesisUtterance(currentTranslation);
          const targetLang = targetLanguage.textContent.trim();
          utterance.lang = languageCodes.speech[targetLang] || "hi-IN";

          // Adjust voice settings
          utterance.volume = 1;
          utterance.rate = 1;
          utterance.pitch = 1;

          // Find a voice that matches the target language
          const voices = window.speechSynthesis.getVoices();
          const targetCode = languageCodes.speech[targetLang].split("-")[0];

          // Look for voices that match our target language
          const matchingVoice = voices.find((voice) =>
            voice.lang.startsWith(targetCode)
          );
          if (matchingVoice) {
            utterance.voice = matchingVoice;
          }

          // Disable play button while speaking
          playButton.disabled = true;
          playButton.classList.add("disabled");

          utterance.onend = () => {
            // Re-enable play button when done
            playButton.disabled = false;
            playButton.classList.remove("disabled");
          };

          // Handle errors
          utterance.onerror = (event) => {
            console.error("Speech synthesis error:", event);
            showError("Failed to play audio. Please try again.");
            playButton.disabled = false;
            playButton.classList.remove("disabled");
          };

          window.speechSynthesis.speak(utterance);
        } else {
          showError("Text-to-speech is not supported in your browser.");
        }
      }

      // Add translation to history
      function addToHistory(original, translation, fromLang, toLang) {
        const timestamp = new Date();
        const historyEntry = {
          original,
          translation,
          fromLang,
          toLang,
          timestamp: timestamp.toISOString(),
        };

        // Add to memory array
        translationHistory.unshift(historyEntry);

        // Save to local storage
        saveHistoryToLocalStorage();

        // Create UI element
        const historyItem = createHistoryItemElement(historyEntry);
        historyContainer.prepend(historyItem);

        // Limit visible history items
        if (historyContainer.children.length > 5) {
          historyContainer.removeChild(historyContainer.lastChild);
        }
      }

      // Create history item element
      function createHistoryItemElement(historyEntry) {
        const { original, translation, fromLang, toLang, timestamp } =
          historyEntry;
        const date = new Date(timestamp);

        const historyItem = document.createElement("div");
        historyItem.className = "history-item";
        historyItem.innerHTML = `
          <div class="flex justify-between mb-2">
            <span class="text-sm font-semibold text-gray-500">${fromLang} → ${toLang}</span>
            <span class="text-xs text-gray-400">${date.toLocaleTimeString()}</span>
          </div>
          <p class="mb-2 text-gray-700">${original}</p>
          <p class="text-gray-900 font-medium">${translation}</p>
          <button class="mt-2 text-blue-500 text-sm play-history-btn">
            <i class="fas fa-volume-up mr-1"></i> Play
          </button>
        `;

        // Add event listener to play button in history item
        const playBtn = historyItem.querySelector(".play-history-btn");
        playBtn.addEventListener("click", () => {
          // Set as current translation and play it
          currentTranslation = translation;
          playTranslation();
        });

        return historyItem;
      }

      // Save history to local storage
      function saveHistoryToLocalStorage() {
        // Limit saved history to prevent excessive storage usage
        const historyToSave = translationHistory.slice(0, 100);
        localStorage.setItem(
          "voiceBridgeHistory",
          JSON.stringify(historyToSave)
        );
      }

      // Load history from local storage
      function loadHistoryFromLocalStorage() {
        const savedHistory = localStorage.getItem("voiceBridgeHistory");
        if (savedHistory) {
          try {
            translationHistory = JSON.parse(savedHistory);

            // Add a few recent items to the main page
            const recentItems = translationHistory.slice(0, 5);
            historyContainer.innerHTML = "";
            recentItems.forEach((entry) => {
              const historyItem = createHistoryItemElement(entry);
              historyContainer.appendChild(historyItem);
            });
          } catch (error) {
            console.error("Error loading history from local storage:", error);
          }
        }
      }

      // Display full history in modal
      function displayFullHistory() {
        fullHistoryContainer.innerHTML = "";

        if (translationHistory.length === 0) {
          fullHistoryContainer.innerHTML = `
            <p class="text-center text-gray-500 py-10">No translation history found.</p>
          `;
          return;
        }

        // Group history items by date
        const groupedHistory = groupHistoryByDate(translationHistory);

        // Create elements for each date group
        Object.keys(groupedHistory).forEach((date) => {
          const dateGroup = document.createElement("div");
          dateGroup.className = "history-date-group";

          // Add date header
          const dateHeader = document.createElement("div");
          dateHeader.className = "history-date-label";
          dateHeader.textContent = date;
          dateGroup.appendChild(dateHeader);

          // Add history items for this date
          groupedHistory[date].forEach((entry) => {
            const historyItem = createHistoryItemElement(entry);
            dateGroup.appendChild(historyItem);
          });

          fullHistoryContainer.appendChild(dateGroup);
        });
      }

      // Group history items by date
      function groupHistoryByDate(history) {
        const grouped = {};

        history.forEach((entry) => {
          const date = new Date(entry.timestamp);
          const dateString = date.toLocaleDateString();

          if (!grouped[dateString]) {
            grouped[dateString] = [];
          }

          grouped[dateString].push(entry);
        });

        return grouped;
      }

      // Clear all history
      function clearAllHistory() {
        if (
          confirm("Are you sure you want to clear all translation history?")
        ) {
          translationHistory = [];
          localStorage.removeItem("voiceBridgeHistory");
          historyContainer.innerHTML = "";
          displayFullHistory(); // Refresh the history modal
        }
      }

      // Handle language selection
      function showLanguageModal(selector) {
        currentLanguageSelector = selector;
        languageModal.classList.remove("hidden");
      }

      // Initialize speech synthesis voices
      function initVoices() {
        if ("speechSynthesis" in window) {
          // Chrome needs this on page load to populate voices
          window.speechSynthesis.getVoices();

          // Chrome fires this event when voices are ready
          if (window.speechSynthesis.onvoiceschanged !== undefined) {
            window.speechSynthesis.onvoiceschanged = function () {
              console.log(
                "Voices loaded:",
                window.speechSynthesis.getVoices().length
              );
            };
          }
        }
      }

      // Event Listeners for push-to-talk
      setupPushToTalk();

      // Add event listener for click as a fallback, but don't use for push-to-talk
      micButton.addEventListener("click", (e) => {
        // This is used for toggle mode only, not for push-to-talk
        e.preventDefault();
        e.stopPropagation();

        // Prevent normal click behavior in push-to-talk mode
        if (isPushToTalk) return;

        if (micButton.classList.contains("disabled")) return;

        if (!isRecording) {
          startRecording();
        } else {
          stopRecording();
        }
      });

      playButton.addEventListener("click", playTranslation);

      sourceLanguage.addEventListener("click", () => {
        showLanguageModal(sourceLanguage);
      });

      targetLanguage.addEventListener("click", () => {
        showLanguageModal(targetLanguage);
      });

      closeModal.addEventListener("click", () => {
        languageModal.classList.add("hidden");
      });

      languageOptions.forEach((option) => {
        option.addEventListener("click", () => {
          if (currentLanguageSelector) {
            currentLanguageSelector.textContent = option.textContent;

            // Update recognition language if source language changed
            if (currentLanguageSelector === sourceLanguage && recognition) {
              recognition.lang =
                languageCodes.speech[option.textContent.trim()] || "te-IN";
            }
          }
          languageModal.classList.add("hidden");
        });
      });

      // Close modal when clicking outside
      languageModal.addEventListener("click", (e) => {
        if (e.target === languageModal) {
          languageModal.classList.add("hidden");
        }
      });

      // History modal event listeners
      viewHistoryButton.addEventListener("click", () => {
        displayFullHistory();
        historyModal.classList.remove("hidden");
      });

      closeHistoryModal.addEventListener("click", () => {
        historyModal.classList.add("hidden");
      });

      clearHistoryButton.addEventListener("click", clearAllHistory);

      // Close history modal when clicking outside
      historyModal.addEventListener("click", (e) => {
        if (e.target === historyModal) {
          historyModal.classList.add("hidden");
        }
      });

      // Check for browser support and initialize
      window.addEventListener("DOMContentLoaded", () => {
        // Initialize speech recognition
        initSpeechRecognition();

        // Initialize speech synthesis voices
        initVoices();

        // Load history from local storage
        loadHistoryFromLocalStorage();

        // If no history was loaded, add sample items
        if (translationHistory.length === 0) {
          // Current timestamp for sample data
          const now = new Date();

          // Add sample history items with timestamps
          const sampleHistory = [
            {
              original: "నమస్కారం, మీరు ఎలా ఉన్నారు?",
              translation: "नमस्ते, आप कैसे हैं?",
              fromLang: "Telugu",
              toLang: "Hindi",
              timestamp: new Date(now - 5 * 60000).toISOString(), // 5 minutes ago
            },
            {
              original: "నేను భారతదేశానికి వెళ్లాలనుకుంటున్నాను",
              translation: "मैं भारत जाना चाहता हूँ",
              fromLang: "Telugu",
              toLang: "Hindi",
              timestamp: new Date(now - 10 * 60000).toISOString(), // 10 minutes ago
            },
          ];

          // Add sample items to history array
          translationHistory = sampleHistory;

          // Save to local storage
          saveHistoryToLocalStorage();

          // Add to UI
          historyContainer.innerHTML = "";
          sampleHistory.forEach((entry) => {
            const historyItem = createHistoryItemElement(entry);
            historyContainer.appendChild(historyItem);
          });
        }

        // Check if it's a touch device
        const isTouchDevice =
          "ontouchstart" in window || navigator.maxTouchPoints > 0;
        if (isTouchDevice) {
          document.querySelector(".push-to-talk-hint").textContent =
            "Press and hold to speak";
        }

        // Update copyright year
        const currentYear = new Date().getFullYear();
        const footerEl = document.querySelector(".footer");
        if (footerEl) {
          footerEl.innerHTML = `&copy; ${currentYear} VoiceBridge | Built by Suraj Mandal`;
        }
      });

      // Request microphone permissions early
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices
          .getUserMedia({ audio: true })
          .then(function (stream) {
            // Permission granted, stop tracks (we just needed permission)
            stream.getTracks().forEach((track) => track.stop());
          })
          .catch(function (err) {
            console.error("Microphone access denied:", err);
            showError(
              "Microphone access denied. Please allow microphone access in your browser settings."
            );
            micButton.classList.add("disabled");
          });
      }

      // Handle visibility change to prevent resource usage when tab is not visible
      document.addEventListener("visibilitychange", () => {
        if (document.hidden && isRecording) {
          stopRecording();
        }
      });
    </script>
  </body>
</html>
